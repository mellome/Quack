{
  "_args": [
    [
      {
        "raw": "rijs@*",
        "scope": null,
        "escapedName": "rijs",
        "name": "rijs",
        "rawSpec": "*",
        "spec": "*",
        "type": "range"
      },
      "/Users/mellome1992/LocalRepository/webtech2-blog/quackapp-frontend/src/main/angular/node_modules/popper"
    ]
  ],
  "_from": "rijs@*",
  "_id": "rijs@0.9.1",
  "_inCache": true,
  "_location": "/rijs",
  "_nodeVersion": "8.9.4",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/rijs_0.9.1_1522019685883_0.6276697362662209"
  },
  "_npmUser": {
    "name": "pemrouz",
    "email": "p3pedram@hotmail.com"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "rijs@*",
    "scope": null,
    "escapedName": "rijs",
    "name": "rijs",
    "rawSpec": "*",
    "spec": "*",
    "type": "range"
  },
  "_requiredBy": [
    "/popper"
  ],
  "_resolved": "https://registry.npmjs.org/rijs/-/rijs-0.9.1.tgz",
  "_shasum": "6a0569a898cc5a5f92bfd59ad866c8ef1a9f2787",
  "_shrinkwrap": null,
  "_spec": "rijs@*",
  "_where": "/Users/mellome1992/LocalRepository/webtech2-blog/quackapp-frontend/src/main/angular/node_modules/popper",
  "author": {
    "name": "Pedram Emrouznejad",
    "url": "https://github.com/pemrouz"
  },
  "bugs": {
    "url": "https://github.com/rijs/fullstack/issues"
  },
  "dependencies": {
    "rijs.components": "*",
    "rijs.core": "*",
    "rijs.css": "*",
    "rijs.data": "*",
    "rijs.fn": "*",
    "rijs.pages": "*",
    "rijs.resdir": "*",
    "rijs.serve": "*",
    "rijs.sessions": "*",
    "rijs.singleton": "*",
    "rijs.sync": "*",
    "utilise": "*"
  },
  "description": "On the server:",
  "devDependencies": {
    "puppeteer": "^1.0.0",
    "rollup": "*",
    "rollup-plugin-async": "*",
    "rollup-plugin-buble": "*",
    "rollup-plugin-commonjs": "*",
    "rollup-plugin-node-resolve": "*",
    "rollup-plugin-nodent": "*",
    "tap": "^10.7.3",
    "uglify-es": "^3.3.10"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-Hl5yWFZUdVePXIOHRrFXGxQZ2+fzWucqqx/aQjkE0PxbmNyOY0WA/SWdDA1eKeqb7lh2a0vcchR9mZLiQ9rHFQ==",
    "shasum": "6a0569a898cc5a5f92bfd59ad866c8ef1a9f2787",
    "tarball": "https://registry.npmjs.org/rijs/-/rijs-0.9.1.tgz",
    "fileCount": 16,
    "unpackedSize": 95202
  },
  "gitHead": "eae9bf8ab528aa4c7e7e8925cdd05f9592962092",
  "homepage": "https://github.com/rijs/fullstack#readme",
  "license": "pemrouz.mit-license.org",
  "main": ".",
  "maintainers": [
    {
      "name": "pemrouz",
      "email": "p3pedram@hotmail.com"
    }
  ],
  "name": "rijs",
  "optionalDependencies": {},
  "readme": "# Ripple Fullstack\r\n\r\nOn the server:\r\n\r\n**`index.js`**\r\n```js\r\nconst ripple = require('rijs')({ dir: __dirname })\r\n```\r\n\r\nOn the client: \r\n\r\n**`pages/index.html`**\r\n```html\r\n<script src=\"/ripple.js\"></script>\r\n```\r\n\r\nRun it:\r\n\r\n```\r\n$ node index.js\r\n```\r\n\r\nThis starts up a server on a random port and statically serves your `/pages` directory. You can also specify a `port` to always use, or pass an existing HTTP `server` (e.g. from express). \r\n\r\nClients will then just be streamed the fine-grained resources they are using (i.e. everything is lazy loaded, no bundling, no over-fetching). \r\n\r\nRipple keeps clients/servers in sync by replicating an immutable log of actions in the background, and subsequently the view - or other modules - which are reactively updated when the local store is updated.\r\n\r\nThat's it! No boilerplate necessary, no build pipeline, no special transpilation, no magical CLI.\r\n\r\nThe basic API is:\r\n\r\n```js\r\nripple(name)        // getter\r\nripple(name, body)  // setter\r\nripple.on('change', (name, change) => { .. })\r\n```\r\n\r\n&nbsp; \r\n## Components\r\n\r\nLet's add a (Web) Component to the page:\r\n\r\n**`index.html`**\r\n```diff\r\n<script src=\"/ripple.js\"></script>\r\n+ <my-app></my-app>\r\n```\r\n\r\nLet's define the component:\r\n\r\n**`resources/my-app.js:`**\r\n\r\n```js\r\nexport default () => ()\r\n```\r\n\r\nRipple is agnostic to _how_ you write your components, they should just be idempotent: a single render function. \r\n\r\nThis is fine:\r\n\r\n**`resources/my-app.js:`**\r\n\r\n```js\r\nexport default (node, data) => node.innerHTML = 'Hello World!'\r\n```\r\n\r\nOr using some DOM-diff helper:\r\n\r\n**`resources/my-app.js:`**\r\n\r\n```js\r\nexport default (node, data) => jsx(node)`<h1>Hello World</h1>`\r\n```\r\n\r\nOr using [once](https://github.com/utilise/once#once)/D3 joins:\r\n\r\n**`resources/my-app.js:`**\r\n\r\n```js\r\nexport default (node, data) => {\r\n  once(node)\r\n    ('h1', 1)\r\n      .text('Hello World')\r\n})\r\n```\r\n\r\nFor more info about writing idempotent components, see [this spec](https://github.com/pemrouz/vanilla).\r\n\r\n&nbsp;\r\n## State/Data\r\n\r\nThe first parameter of the component is the node to update. \r\n\r\nThe second parameter contains all the state and data the component needs to render:\r\n\r\n```js\r\nexport default function component(node, data){ ... }\r\n```\r\n\r\n* You can inject data resources by adding the name of the resources to the data attribute:\r\n\r\n    ```html\r\n    <my-shop data=\"stock\">\r\n    ```\r\n\r\n    ```js\r\n    export default function shop({ stock }){ ... }\r\n    ```\r\n\r\n    Declaring the data needed on a component is used to reactively rerender it when the data changes. \r\n\r\n    Alternatively, you can use `ripple.pull` directly to retrieve a resource, which has similar semantics to [dynamic `import()`](https://github.com/tc39/proposal-dynamic-import) (i.e. resolves from local cache or returns a single promise):\r\n\r\n    ```js\r\n    const dependency = await pull('dependency')\r\n    ```\r\n\r\n* The other option is to explicitly pass down data to the component from the parent:\r\n\r\n    ```js\r\n    once(node)\r\n      ('my-shop', { stock })\r\n    ```\r\n\r\n    The helper function will set the state and redraw, so redrawing a parent will redraw it's children. If you want to do it yourself:\r\n\r\n    ```js\r\n    element.state = { stock }\r\n    element.draw()\r\n    ```\r\n\r\n&nbsp;\r\n## Defaults\r\n\r\nYou can set defaults using the ES6 syntax:\r\n\r\n```js\r\nexport default function shop({ stock = [] }){ ... }\r\n```\r\n\r\nIf you need to persist defaults on the component's state object, you can use a small [helper function](https://github.com/utilise/utilise#--defaults):\r\n\r\n```js\r\nexport default function shop(state){ \r\n  const stock = defaults(state, 'stock', [])\r\n}\r\n```\r\n\r\n&nbsp;\r\n## Updates\r\n\r\n#### Local state\r\n\r\nWhenever you need to update local state, just change the `state` and invoke a redraw (like a game loop):\r\n\r\n```js\r\nexport default function abacus(node, state){ \r\n  const o = once(node)\r\n      , { counter = 0 } = state\r\n\r\n  o('span', 1)\r\n    .text(counter)\r\n\r\n  o('button', 1)\r\n    .text('increment')\r\n    .on('click.increment' d => {\r\n      state.counter++\r\n      o.draw()\r\n    })\r\n}\r\n```\r\n\r\n#### Global state\r\n\r\nWhenever you need to update global state, you can simply compute the new value and register it again which will trigger an update:\r\n\r\n```js\r\nripple('stock', {\r\n  apples: 10\r\n, oranges: 20\r\n, pomegranates: 30\r\n})\r\n```\r\n\r\nOr if you just want to change a part of the resource, use a [functional operator](https://github.com/utilise/utilise#--set) to apply a finer-grained diff and trigger an update:\r\n\r\n```js\r\nupdate('pomegranates', 20)(ripple('stock'))\r\n// same as: set({ type: 'update', key: 'pomegranate', value: 20 })(ripple('stock'))\r\n```\r\n\r\nUsing logs of atomic diffs combines the benefits of immutability with a saner way to synchronise state across a distributed environment.\r\n\r\nComponents are rAF batched by default. You can access the list of all relevant changes since the last render in your component via `node.changes` to make it more performant if necessary.\r\n\r\n&nbsp;\r\n## Events\r\n\r\nDispatch an event on the root element to communicate changes to parents (`node.dispatchEvent`).\r\n\r\n&nbsp;\r\n## Routing\r\n\r\nRouting is handled by your top-level component: Simply parse the URL to determine what children to render and invoke a redraw of your application when the route has changed: \r\n\r\n```js\r\nexport function app(node, data){\r\n  const o = once(node)\r\n      , { pathname } = location\r\n\r\n  o('page-dashboard', pathname == '/dashboard')\r\n  o('page-login', pathname == '/login')\r\n \r\n  once(window)\r\n    .on('popstate.nav', d => o.draw())\r\n}\r\n```\r\n\r\nThis solution is not tied to any library, and you may not need one at all. \r\n\r\nFor advanced uses cases, checkout [decouter](https://github.com/pemrouz/decouter).\r\n\r\n&nbsp;\r\n## Styling\r\n\r\nYou can author your stylesheets assuming they are completely isolated, using the Web Component syntax (`:host` etc).\r\n\r\nThey will either be inserted in the shadow root of the element, or scoped and added to the head if there is no shadow.\r\n\r\nBy default, the CSS resource `component-name.css` will be automatically applied to the component `component-name`.\r\n\r\nBut you can apply multiple stylesheets to a component too: just extend the `css` attribute. \r\n\r\n&nbsp;\r\n## Folder Convention\r\n\r\nAll files in your `/resources` folder will be automatically registered (except tests etc). You can organise it as you like, but I recommend using the convention: a folder for each component (to co-locate JS, CSS and tests), and a `data` folder for the resources that make up your domain model.\r\n\r\n```\r\nresources\r\n├── data\r\n│   ├── stock.js\r\n│   ├── order.js\r\n│   └── ...\r\n├── my-app\r\n│   ├── my-app.js\r\n│   ├── my-app.css\r\n│   └── test.js\r\n├── another-component\r\n│   ├── another-component.js\r\n│   ├── another-component.css\r\n│   └── test.js\r\n└── ...\r\n```\r\n\r\nHot reloading works out of the box. Any changes to these files will be instantly reflected everywhere.\r\n\r\n&nbsp;\r\n## Loading Resources\r\n\r\nYou can also get/set resources yourselves imperatively:\r\n\r\n```js\r\nripple(name)       // getter\r\nripple(name, body) // setter\r\n```\r\n\r\nOr for example import resources from other packages:\r\n\r\n```js\r\nripple\r\n  .resource(require('external-module-1'))\r\n  .resource(require('external-module-2'))\r\n  .resource(require('external-module-3'))\r\n```\r\n\r\nYou can also create resources that proxy to [fero](https://github.com/pemrouz/fero)) services too.\r\n\r\n&nbsp;\r\n## Offline\r\n\r\nResources are currently cached in `localStorage`. \r\n\r\nThis means even _before_ any network interaction, your application renders the last-known-good-state for a superfast startup. \r\n\r\nThen as resources are streamed in, the relevant parts of the application are updated.\r\n\r\nNote: Caching of resources will be improved by using ServiceWorkers under the hood instead soon ([#27](https://github.com/rijs/fullstack/issues/27))\r\n\r\n&nbsp;\r\n## Render Middleware\r\n\r\nBy default the draw function just invokes the function on an element. You can extend this without any framework hooks using the explicit decorator pattern:\r\n\r\n```js\r\n// in component\r\nexport default function component(node, data){\r\n  middleware(node, data)\r\n}\r\n\r\n// around component\r\nexport default middleware(function component(node, data){\r\n  \r\n})\r\n\r\n// for all components\r\nripple.draw = middleware(ripple.draw)\r\n```\r\n\r\nA few useful middleware included in this build are:\r\n\r\n### Needs\r\n\r\n[This middleware](https://github.com/rijs/needs#ripple--needs) reads the `needs` header and applies the attributes onto the element. The component does not render until all dependencies are available. This is useful when a component needs to define its own dependencies. You can also supply a function to dynamically calculate the required resources.\r\n\r\n```js\r\nexport default {\r\n  name: 'my-component'\r\n, body: function(){}\r\n, headers: { needs: '[css=..][data=..]' }\r\n}\r\n```\r\n\r\n### Shadow\r\n\r\nIf supported by the browser, a shadow root will be created for each component. The component will render into the shadow DOM rather than the light DOM.\r\n\r\n\r\n### Perf (Optional)\r\n\r\nThis one is not included by default, but you can use this to log out the time each component takes to render.\r\n\r\nOther debugging tips: \r\n\r\n* Check `ripple.resources` for a snapshot of your application. Resources are in the [tuple format](https://github.com/rijs/core#ripple--core) `{ name, body, headers }`.\r\n\r\n* Check `$0.state` on an element to see the state object it was last rendered with or manipulate it.\r\n\r\n&nbsp;\r\n## Sync\r\n\r\nYou can define a `from` function in the resource headers which will process requests from the client:\r\n\r\n```js\r\nconst from = (req, res) => \r\n  req.data.type == 'REGISTER' ? register(req, res)\r\n: req.data.type == 'FORGOT'   ? forgot(req, res)\r\n: req.data.type == 'LOGOUT'   ? logout(req, res)\r\n: req.data.type == 'RESET'    ? reset(req, res)\r\n: req.data.type == 'LOGIN'    ? login(req, res)\r\n                              : false\r\n\r\nmodule.exports = { \r\n  name: 'users'\r\n, body: {}\r\n, headers: { from } \r\n}\r\n```\r\n\r\nThis can return a single value, a promise or a stream. On the client you make requests with `ripple.send(name, type, value)`. This returns an awaitable [stream](https://github.com/utilise/emitterify/#emitterify).\r\n\r\nYou can also use the `.subscribe` API to subscribe to all or part of a resource. The key can be arbitrarily deep, and multiple keys will be merged into a single object. \r\n\r\n```js\r\nripple.subscribe(name, key)\r\nripple.subscribe(name, [keys])\r\n```\r\n\r\nSubscriptions are automatically deduplicated are ref-counted, so components can indepedently subscribe to the data they need without worrying about this.\r\n\r\nNote that you can also use `ripple.get` instead of subscribe if you just want to get a single value and then automatically unsubscribe.\r\n\r\n&nbsp;\r\n## Ripple Minimal\r\n\r\nIf you have don't have backend for your frontend, checkout [rijs/minimal](https://github.com/rijs/minimal) which is a client-side only build of Ripple.\r\n\r\nYou can also adjust your own framework by [adding/removing modules](https://github.com/rijs/minimal/blob/master/src/index.js#L1-L11).\r\n\r\n&nbsp;\r\n## Docs\r\n\r\nSee [rijs/docs](https://github.com/rijs/docs) for more guides, index of modules, API reference, etc\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/rijs/fullstack.git"
  },
  "scripts": {
    "build": "npm run clean && npm run client && npm run rollup && npm run minify && npm run gzip",
    "clean": "rm -rf ./client/ripple.*",
    "client": "uglifyjs index.js -b -d client=true -c > ./client/ripple.js",
    "gzip": "gzip -c ./client/ripple.min.js > ./client/ripple.min.js.gz",
    "minify": "uglifyjs ./client/ripple.bundle.js -m -c keep_fargs=false > ./client/ripple.min.js",
    "postversion": "git push && git push --tags",
    "rollup": "rollup -c",
    "test": "tap ./tests/*.js",
    "version": "npm run build && git add -A"
  },
  "version": "0.9.1"
}
